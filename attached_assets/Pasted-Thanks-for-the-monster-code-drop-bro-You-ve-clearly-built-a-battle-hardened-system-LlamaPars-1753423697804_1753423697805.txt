Thanks for the monster code drop, bro ğŸ§ âš™ï¸ Youâ€™ve clearly built a battle-hardened system â€” LlamaParse fallback + OCR pipeline + CLI detection â€” chefâ€™s kiss. But from your message:

âŒ It doesnâ€™t fallback to Tesseract OCR even when LlamaParse fails.

Let's debug it like a cleanroom autopsy.

ğŸ§  What should trigger fallback:
In your method extractFromPDF():

ts
Copy
Edit
if (hasContent && hasRealText) {
  // LlamaParse result is good
  return extractedText;
} else {
  // Trigger OCR fallback
}
You have:

hasContent = extractedText.length > 100

hasRealText = extractedText.replace(/\s+/g, '').length > 50

And only if both fail, OCR fallback runs.

ğŸ§¨ Root Cause Candidates
1. LlamaParse returns garbage, but passes both checks
Your check:

ts
Copy
Edit
const hasRealText = extractedText.replace(/[\s\n\r-]/g, '').length > 50;
If LlamaParse returns gibberish but long enough (like "Jatuiotn OUB undueinsn 129"), it still passes this, so fallback never triggers.

ğŸ’¥ Thatâ€™s probably whatâ€™s happening.

2. Your OCR fallback does run, but returns less text than LlamaParse
You do check this:

ts
Copy
Edit
if (ocrNonWhitespace > llamaNonWhitespace) {
  return ocrText;
}
But what if:

Both are garbage, but LlamaParse is "slightly longer"?

You never want OCR to be skipped if it has Thai text?

ğŸ›  Fixes You Can Apply
âœ… Fix 1: Add semantic filter to LlamaParse result
Instead of only length, check if Thai exists:

ts
Copy
Edit
const hasThai = /[\u0E00-\u0E7F]/.test(extractedText);
Update logic:

ts
Copy
Edit
if (hasContent && hasRealText && hasThai) {
  return extractedText;
}
This prevents fallback suppression due to garbage English-like junk.

âœ… Fix 2: Force OCR if no Thai
Update your fallback logic:

ts
Copy
Edit
if (!hasThaiText && hasThaiOCRText) {
  return ocrText;
}
Or even better, in plain speak:

ts
Copy
Edit
if (ocrHasMoreText || ocrHasMoreThai) {
  return ocrText;
}
You already extract both character counts â€” use them!

âœ… Fix 3: Add debug print before returning LlamaParse
Before returning:

ts
Copy
Edit
console.log("âš ï¸ Skipping OCR fallback because LlamaParse looks valid-ish");
console.log(`ğŸ“‰ LlamaParse length: ${extractedText.length}`);
console.log(`ğŸ“‰ Thai text detected: ${hasThai}`);
âœ… Fix 4: Hard force OCR if file is from known bad batch
For example:

ts
Copy
Edit
if (fileName.includes("PROP") || extractedText.includes("Jatiatam")) {
  console.log("âš ï¸ Detected known garbled output â€” forcing OCR fallback");
  const ocrText = await this.ocrThaiPDF(filePath);
  return ocrText;
}
Bonus: Make fallback more confident
In ocrThaiPDF(), after building allText, throw in:

ts
Copy
Edit
if (/[\u0E00-\u0E7F]{5}/.test(allText)) {
  // Found 5+ Thai chars in a row = real content
}
That lets you ignore broken OCR that says:

Copy
Edit
à¹à¸­à¸› TMRW à¸«à¸£à¸·à¸­ SMS à¸à¸´à¸¡à¸à¹Œ SHP3 à¸•à¸²à¸¡à¸”à¹‰à¸§à¸¢...
vs

Copy
Edit
à¸à¸£à¸—à¸”à¸¥à¸«à¸ªà¸²à¸²à¸²à¸²à¸² à¸™à¸„à¸¶
TL;DR
ğŸ’¡ Your fallback is solid â€” but the conditions are too forgiving when LlamaParse outputs garbage but technically long text. Add a Thai text check (/[\u0E00-\u0E7F]/) to make your fallback trigger correctly.

Let me know if you want me to rewrite that section for max reliability and Thai-awareness ğŸ‘¨â€ğŸ”§