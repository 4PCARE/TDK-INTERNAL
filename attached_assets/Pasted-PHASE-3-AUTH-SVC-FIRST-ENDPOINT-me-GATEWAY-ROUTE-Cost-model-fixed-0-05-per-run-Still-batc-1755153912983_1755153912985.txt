PHASE 3 — AUTH-SVC FIRST ENDPOINT (/me) + GATEWAY ROUTE
Cost model: fixed $0.05 per run. Still batch related edits together for accuracy.

Goal
- Implement a minimal, contract-compliant `/me` in `auth-svc` that returns a stubbed user.
- Add a tiny Zod-based (or fallback) response validator inside `auth-svc` HTTP layer.
- Wire `api-gateway` to route GET `/me` to `auth-svc` (keep legacy fallback via ENV if needed).
- No DB, no sessions yet. This is a functional stub to validate wiring.

Hard rules
- Max 600 lines/file, ≤80 lines/function, complexity ≤10.
- No business logic beyond returning a stub user object that matches the contract.
- Keep changes surgical; do not modify unrelated services or fragile root configs.

MICRO-BATCH A — IMPLEMENT /me IN AUTH-SVC
Files to change (3 total):
1) CREATE: services/auth-svc/src/infrastructure/http/validate.ts  (≈ 35 lines)
   - Try/catch dynamic import of `zod`, else fallback to a tiny shape check.
   - Export: `validateUser(data): data is { id: string; email: string; roles: string[] }`
   - Validate only fields required by /packages/contracts/common/schemas.yaml → User

2) EDIT: services/auth-svc/src/infrastructure/http/routes.ts  (+~25 lines)
   - Add GET `/me` handler:
     - const payload = { id: "00000000-0000-4000-8000-000000000000", email: "dev@example.com", roles: ["admin"] }
     - validate with `validateUser(payload)`; on fail, 500 `{ message: "Contract violation" }`
     - on pass, 200 with payload
   - Keep existing /healthz and /readyz stubs

3) VERIFY buildability
   - Run: cd services/auth-svc && npx tsc --noEmit
   - Report: files touched + +/- line counts; tsc result

STOP after MICRO-BATCH A and wait for approval.

MICRO-BATCH B — GATEWAY ROUTE TO AUTH-SVC (/me)
Files to change (1 total):
1) EDIT: services/api-gateway/src/infrastructure/http/routing.ts  (+~20 lines)
   - Add GET `/me` route that proxies to `${process.env.AUTH_SVC_URL ?? "http://localhost:3001"}/me`
   - Use existing `proxy()` and same try/catch → 502 on upstream error
   - Keep existing legacy routes (chat/search/documents/webhook) untouched

VERIFY:
- cd services/api-gateway && npx tsc --noEmit
- Report: lines changed; tsc result

STOP after MICRO-BATCH B and wait for approval.

Implementation hints (keep it short):
// services/auth-svc/src/infrastructure/http/validate.ts
export function validateUser(d: any): d is { id: string; email: string; roles: string[] } {
  try {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const z: typeof import("zod") = require("zod");
    const S = z.object({
      id: z.string().uuid(),
      email: z.string().email(),
      roles: z.array(z.string()),
    });
    S.parse(d);
    return true;
  } catch {
    return !!(d && typeof d.id === "string" && typeof d.email === "string" && Array.isArray(d.roles));
  }
}

// services/auth-svc/src/infrastructure/http/routes.ts (excerpt)
import type { Request, Response } from "express";
import { validateUser } from "./validate";
export function registerRoutes(app: any) {
  app.get("/healthz", (_req: Request, res: Response) => res.status(200).json({ ok: true }));
  app.get("/readyz", (_req: Request, res: Response) => res.status(200).json({ ready: true }));
  app.get("/me", (_req: Request, res: Response) => {
    const payload = { id: "00000000-0000-4000-8000-000000000000", email: "dev@example.com", roles: ["admin"] };
    if (!validateUser(payload)) return res.status(500).json({ message: "Contract violation" });
    return res.status(200).json(payload);
  });
}

// services/api-gateway/src/infrastructure/http/routing.ts (excerpt)
import type { Request, Response } from "express";
import { proxy } from "./proxy";
const authBase = process?.env?.AUTH_SVC_URL ?? "http://localhost:3001";
export function registerLegacyRoutes(app: any) {
  // existing /chat, /search, /documents, /webhook ...
  app.get("/me", async (req: Request, res: Response) => {
    try {
      const r = await proxy(req, authBase, "/me");
      res.status(r.status).set(r.headers).send(r.data);
    } catch (e: any) {
      res.status(502).json({ message: "Upstream proxy error", detail: String(e?.message || e) });
    }
  });
}

Report format each stop:
- Files touched (count + list)
- Lines added/removed per file
- tsc result for the service(s)
- Restarts performed (expect 0)
- Confirmation no unrelated files changed
