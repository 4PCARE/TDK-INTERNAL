Here’s the fastest knife-through-butter order—apply, typecheck, move on:

CreateAgentChatbot guardrails (kills the top UI error)

Never send null for guardrailsConfig.

const gc = agent.guardrailsConfig;
const guardrailsConfigClean =
  gc && Object.keys(gc).length ? gc : undefined;
// drop any `brandVoice` unless it’s in shared types
saveAgentMutation.mutate({ ...agent, guardrailsConfig: guardrailsConfigClean });


Update the local form/type so agentConfig.guardrailsConfig?: ... never becomes null.

UI state/query typing sweep (removes all those “property X on type {}” errors)

DataConnections.tsx

type ConnectionData = { connectionString: string; host?: string; port?: number };
const [connectionData, setConnectionData] = useState<ConnectionData | null>(null);
// use connectionData?.host etc.; when copying, guard with `connectionData && ...`


Integrations.tsx

type WebhookData = { webhookUrl: string; legacyWebhookUrl?: string };
const [webhookData, setWebhookData] = useState<WebhookData | null>(null);


LiveChatWidget.tsx, Settings.tsx, UserManagement.tsx

type User = { email?: string; role?: 'admin'|'user' };
const { data: user } = useQuery<User>(...);


UserFeedback.tsx

const safeCats = (aiCategories ?? []).filter(Boolean) as string[];
{safeCats.map((category) => ( ... ))}
// and fix implicit any:
feedback.tags.map((tag: unknown) => String(tag))


Server bootstrap fixes (big cascade reducer)

Imports/exports:

server/index.ts: make imports match actual exports (switch default↔named so they align).

global.wsClients

Add server/global.d.ts:

declare global { var wsClients: Set<any> | undefined; }
export {};


Init once: global.wsClients ||= new Set();

Microsoft auth types: install @types/passport-azure-ad or declare:

// types/passport-azure-ad.d.ts
declare module 'passport-azure-ad';


AgentBot + Line webhook (union & defaults)

Guardrails presence:

if ('guardrailsConfig' in agentData && (agentData as any).guardrailsConfig) {
  guardrailsService = new GuardrailsService((agentData as any).guardrailsConfig);
}


Search weights & token limit:

const { keywordWeight = 0.5, vectorWeight = 0.5, finalTokenLimit } = searchConfig ?? {};
const finalCharLimit = (finalTokenLimit ?? 2048) * 4;


Message narrowing:

type Minimal = { type?: string; content?: string };
const isBotMessage = (m: unknown): m is Minimal => !!m && typeof (m as any).type === 'string';
const contextMessage = isBotMessage(message) ? (message.content ?? '') : (message as any).message;
if (isBotMessage(message) && message.type === 'image') { ... }


DB/schema alignment (drizzle insert/select shape)

Remove fields not in tables now: createdBy, isPublic, addedAt, originalDocumentId.

Fix required fields:

createAgentChatbot must include systemPrompt.

hrApi.ts: use employee.name; delete firstName/lastName references and matching select columns.

Debug & routes cleanup (explicit types + missing args)

Provide types for locals to silence implicit any:

const recentChatHistory: any[] = [];
let filenameResults: any[] = []; // etc.


Provide the missing userQuestion argument to suggestQueries(...).

Define or remove dead paths: specificDocumentIds, searchResults.

TS config / stray options

Enable --target es2015 or --downlevelIteration to allow [...new Set(...)].

Remove nonexistent options (e.g., verboseMode in documentProcessor reader options).

Misc one-liners spotted

routes.ts: ensure agentId passed to getChatHistoryWithMemoryStrategy is a number, not undefined.

routes.ts: replace nonexistent saveChatMessage call or implement it; otherwise use the existing getChatMessages flow.

analytics.ts: don’t reference documentAccess before it’s declared—split the query construction into two steps.