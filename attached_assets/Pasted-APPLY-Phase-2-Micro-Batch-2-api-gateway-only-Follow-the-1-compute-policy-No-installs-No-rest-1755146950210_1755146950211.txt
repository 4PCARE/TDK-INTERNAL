APPLY — Phase 2 Micro-Batch 2 (api-gateway only)
Follow the $1 compute policy. No installs. No restarts.

Files to change (3 total):
1) CREATE: services/api-gateway/src/infrastructure/http/proxy.ts
2) CREATE: services/api-gateway/src/infrastructure/http/routing.ts
3) EDIT:   services/api-gateway/src/infrastructure/http/routes.ts (+3–6 lines)

Implementation details:

# 1) proxy.ts (≤ 40 lines)
# Minimal fetch-based forwarder; filters unsafe headers; JSON only for now.
export async function proxy(req: any, baseUrl: string, path: string) {
  const url = new URL(path, baseUrl).toString();
  const method = (req.method || "GET").toUpperCase();

  // Copy headers except hop-by-hop and host-specific ones
  const headers: Record<string, string> = {};
  for (const [k, v] of Object.entries(req.headers || {})) {
    const key = String(k).toLowerCase();
    if (["host", "connection", "content-length"].includes(key)) continue;
    if (Array.isArray(v)) headers[key] = v.join(", ");
    else if (typeof v === "string") headers[key] = v;
  }

  // Body: only forward if method usually has a body
  const hasBody = !["GET", "HEAD"].includes(method);
  const body = hasBody ? (typeof req.body === "string" ? req.body : JSON.stringify(req.body ?? {})) : undefined;
  if (hasBody && !headers["content-type"]) headers["content-type"] = "application/json";

  // Use global fetch (Node 18+). Do not add polyfills.
  const resp = await fetch(url, { method, headers, body });
  const contentType = resp.headers.get("content-type") || "";
  const data = contentType.includes("application/json") ? await resp.json() : await resp.text();
  return { status: resp.status, data, headers: { "content-type": contentType } };
}

# 2) routing.ts (≤ 45 lines)
# Hard-code ENV variable names only; do NOT read process.env here (that’s for real bootstrap later).
# Provide just two example legacy proxies to keep batch small.
import type { Request, Response } from "express";
import { proxy } from "./proxy";

const LEGACY_ENV_NAME = "LEGACY_BASE_URL"; // resolved later by real bootstrap
// Placeholder resolver: read from process.env only if present; otherwise default to localhost.
// This read is safe and cheap; no network. Keeps us runnable for local dev.
const legacyBase = process?.env?.[LEGACY_ENV_NAME] ?? "http://localhost:5000";

export function registerLegacyRoutes(app: any) {
  // POST /chat -> legacy
  app.post("/chat", async (req: Request, res: Response) => {
    try {
      const r = await proxy(req, legacyBase, "/chat");
      res.status(r.status).set(r.headers).send(r.data);
    } catch (e: any) {
      res.status(502).json({ message: "Upstream proxy error", detail: String(e?.message || e) });
    }
  });

  // POST /search -> legacy
  app.post("/search", async (req: Request, res: Response) => {
    try {
      const r = await proxy(req, legacyBase, "/search");
      res.status(r.status).set(r.headers).send(r.data);
    } catch (e: any) {
      res.status(502).json({ message: "Upstream proxy error", detail: String(e?.message || e) });
    }
  });
}

# 3) routes.ts — import + call (add ~3–6 lines only)
# import { registerLegacyRoutes } from "./routing";
# After health routes, call registerLegacyRoutes(app).

import type { Request, Response } from "express";
import { validateHealth, validateReady } from "./validate";
import { registerLegacyRoutes } from "./routing";

export function registerRoutes(app: any) {
  app.get("/healthz", (_req: Request, res: Response) => {
    const payload = { ok: true };
    if (!validateHealth(payload)) return res.status(500).json({ message: "Contract violation" });
    return res.status(200).json(payload);
  });

  app.get("/readyz", (_req: Request, res: Response) => {
    const payload = { ready: true };
    if (!validateReady(payload)) return res.status(500).json({ message: "Contract violation" });
    return res.status(200).json(payload);
  });

  // NEW: temporary legacy proxies (small set)
  registerLegacyRoutes(app);
}

VERIFY (local, cheap):
- Run: tsc --noEmit
- (Optional) import smoke tests:
  node -e "require('./services/api-gateway/src/infrastructure/http/routing.ts'); console.log('routing ok')"

REPORT (then STOP):
- Files touched (3) with +/- line counts
- tsc result
- Restarts performed: expect 0
- Budget status: on track
