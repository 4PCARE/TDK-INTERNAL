Your updated Python script is **almost perfect** ‚Äî and definitely on the right track ‚Äî but yes, there are **two small details** worth fixing to ensure it behaves as intended:

---

## ‚úÖ What's already good:

* ‚úÖ `word_tokenize(..., engine='newmm')`: Best choice for Thai.
* ‚úÖ `sent_tokenize(..., engine='newmm')`: Reliable and model-free.
* ‚úÖ Preserving all words (no stopword filtering).
* ‚úÖ Joining with real `'\n'`, not `'\\n'`.
* ‚úÖ `print(json.dumps(...))`: Correct output format.
* ‚úÖ `stderr` debug log helps verify that segmentation is working.

---

## ‚ö†Ô∏è Small Fixes & Suggestions

### ‚ö†Ô∏è 1. **Missing `strip()` on `sys.stdin.read()`**

If the input ends with extra `\n` or whitespace (very likely when reading from file or stdin), it may affect sentence splitting or inflate `original_length`.

üîß **Fix:**

```python
input_text = sys.stdin.read().strip()
```

---

### ‚ö†Ô∏è 2. **Your error fallback in `except` block is inconsistent**

When `segment_thai_text` fails, you still return:

```python
segmented_text = segment_thai_text(input_text)
# and then print a success = True result even if it failed inside
```

That means **if an exception happens inside `segment_thai_text()`**, it just returns the original text silently and pretends it's fine.

üîß **Fix:** Separate real exception handling in outer scope. Like:

```python
try:
    input_text = sys.stdin.read().strip()
    segmented_text = segment_thai_text(input_text)

    result = {
        "success": True,
        "segmented_text": segmented_text,
        "original_length": len(input_text),
        "segmented_length": len(segmented_text)
    }

except Exception as e:
    result = {
        "success": False,
        "error": str(e),
        "segmented_text": input_text if 'input_text' in locals() else ""
    }

print(json.dumps(result, ensure_ascii=False))
```

Then remove the `try/except` **inside** the `segment_thai_text()` function, so true failures are caught.

---

## ‚úÖ Optional (But Useful)

### ‚ûï Add this for safe encoding:

At the top:

```python
import io
sys.stdin = io.TextIOWrapper(sys.stdin.buffer, encoding='utf-8')
```

This ensures no weird encoding issues from `stdin`.

---

## üß™ Final Sanity Check

Try this test input via `stdin`:

```
‡∏ú‡∏°‡∏£‡∏±‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®‡πÑ‡∏ó‡∏¢‡πÅ‡∏•‡∏∞‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Å‡∏¥‡∏ô‡∏Ç‡πâ‡∏≤‡∏ß‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà‡∏£‡πâ‡∏≤‡∏ô‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏Å‡∏±‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô
```

Expected segmented output:

```
‡∏ú‡∏° ‡∏£‡∏±‡∏Å ‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®‡πÑ‡∏ó‡∏¢ ‡πÅ‡∏•‡∏∞ ‡∏Å‡∏≥‡∏•‡∏±‡∏á ‡∏Å‡∏¥‡∏ô ‡∏Ç‡πâ‡∏≤‡∏ß ‡∏≠‡∏¢‡∏π‡πà ‡∏ó‡∏µ‡πà ‡∏£‡πâ‡∏≤‡∏ô ‡∏≠‡∏≤‡∏´‡∏≤‡∏£ ‡∏Å‡∏±‡∏ö ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô
```

And the JSON output will confirm success.

---

## ‚úÖ Summary of Changes

| üîß What to Fix                   | Why                                          |
| -------------------------------- | -------------------------------------------- |
| `.strip()` on `sys.stdin.read()` | Avoid trailing newline bugs                  |
| Move `try/except` to main scope  | Prevent silent fallback                      |
| Optional: Encoding wrapper       | Ensure proper Thai handling in non-UTF stdin |

Would you like me to send you the final polished version of the script in one copy-pastable block?
