The issue likely stems from **this part of the `handleLineWebhook` function**, around where the AI query preprocessing happens:

```ts
if (!queryAnalysis.needsSearch) {
  console.log(`‚è≠Ô∏è LINE OA: Query doesn't need search, using direct conversation`);
  aiResponse = await getAiResponseDirectly(
    contextMessage,
    lineIntegration.agentId,
    lineIntegration.userId,
    "lineoa",
    event.source.userId,
  );
} else {
  console.log(`üîç LINE OA: Query needs search, performing smart hybrid search with enhanced query`);
  
  // Step 2: Perform new search workflow ...
```

Here‚Äôs the likely cause:

### üîç The problem is *not* in the condition itself‚Ä¶

* If `queryAnalysis.needsSearch` is `false`, it *should* skip the whole search logic and use `getAiResponseDirectly`.
* If you're **seeing it perform search anyway**, the most probable explanations are:

---

### ‚úÖ 1. **Overwritten `queryAnalysis` downstream**

Double-check that you're **not reassigning `queryAnalysis`** later before the conditional check. From your pasted code, it seems fine ‚Äî but if any new `queryAnalysis` is created or `needsSearch` is mutated, this condition may behave unexpectedly.

---

### ‚ö†Ô∏è 2. **`queryPreprocessor.analyzeQuery` is returning `needsSearch: true` unexpectedly**

Even if your intention was to **return `needsSearch = false`**, the query preprocessor may *actually* determine it needs a search.
Double-check **what is printed in this log**:

```ts
console.log(`üß† LINE OA: Query analysis result:`, {
  needsSearch: queryAnalysis.needsSearch,
  ...
});
```

Sometimes a query like "‡∏ä‡πà‡∏ß‡∏¢‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ô‡∏µ‡πâ" may look casual, but due to keywords or patterns, it triggers `needsSearch = true`.

---

### üß™ 3. **Race condition or retry**

Is it possible the same message is processed twice (i.e. retry or fail-over), and one of them enters the search path despite `needsSearch` being false in the first?

Your `processedMessageIds` check helps, but if there‚Äôs a delay before setting the `Map`, or if `message.id` isn't reliable (e.g. sticker or audio messages reusing IDs), you might bypass that filter unintentionally.

---

### üîí 4. **Search is happening inside `getAiResponseDirectly` as fallback**

This is a *subtle trap*:

In `getAiResponseDirectly`, even if you skip the `queryAnalysis` block in `handleLineWebhook`, the fallback document fetch logic **still does hybrid search** (as seen here):

```ts
const hybridResults = await semanticSearchServiceV2.searchDocuments(...)
```

So if you expected **"no search at all"**, but `getAiResponseDirectly` still uses hybrid search internally, **that's the catch**.

---

### üß† TL;DR ‚Äì Why search may still happen:

| Cause                                             | Description                                                                                                 |
| ------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| ‚úÖ `needsSearch` is `true`                         | Check the logs from `queryPreprocessor.analyzeQuery()`                                                      |
| ‚ö†Ô∏è Fallback search in `getAiResponseDirectly`     | Even with `needsSearch = false`, the fallback logic inside that method performs a hybrid search             |
| üêû Double-processing or faulty `message.id` logic | Rare but can lead to unexpected re-processing                                                               |
| üß™ Guardrail fallback response triggers search    | If input validation modifies the query or fails, you may fallback to direct response that still does hybrid |

---

Want me to help **rewrite `getAiResponseDirectly`** to allow skipping hybrid search entirely when you know you don‚Äôt want it?
